#include <ros/ros.h>
#include <sensor_msgs/Image.h>
#include <cv_bridge/cv_bridge.h>
#include <pcl_ros/point_cloud.h>
#include <pcl_conversions/pcl_conversions.h>
#include <image_transport/image_transport.h>
#include <pcl/point_types.h>
#include <pcl/range_image/range_image.h>
#include <pcl/range_image/range_image_spherical.h>
#include <pcl/filters/filter.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl/impl/point_types.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <armadillo>
#include <message_filters/subscriber.h>
#include <message_filters/time_synchronizer.h>
#include <message_filters/synchronizer.h>
#include <message_filters/sync_policies/approximate_time.h>
#include <pcl/filters/statistical_outlier_removal.h>
#include <chrono>

using namespace Eigen;
using namespace sensor_msgs;
using namespace message_filters;
using namespace std;

typedef pcl::PointCloud<pcl::PointXYZI> PointCloud;

// Publishers
ros::Publisher pcOnimg_pub;
ros::Publisher pc_pub;

float maxlen = 100.0;      // Maximum LiDAR distance
float minlen = 0.01;      // Minimum LiDAR distance
float max_FOV = 3.0;      // Camera max FOV (radians)
float min_FOV = 0.4;      // Camera min FOV (radians)
float angular_resolution_x = 0.3f; // Reduced for denser point cloud
float angular_resolution_y = 1.2f; // Adjusted for better vertical resolution
float max_angle_width = 360.0f;
float max_angle_height = 180.0f;
float interpol_value = 30.0; // Increased for more interpolated lines
double max_var = 50.0; 
bool f_pc = true; 

// Input topics 
std::string imgTopic = "/camera/color/image_raw";
std::string pcTopic = "/velodyne_points";

// Calibration matrices
Eigen::MatrixXf Tlc(3,1); // Translation matrix LiDAR-camera
Eigen::MatrixXf Rlc(3,3); // Rotation matrix LiDAR-camera
Eigen::MatrixXf Mc(3,4);  // Camera calibration matrix

// Range image parameters
boost::shared_ptr<pcl::RangeImageSpherical> rangeImage;
pcl::RangeImage::CoordinateFrame coordinate_frame = pcl::RangeImage::LASER_FRAME;

// Bilateral filter for interpolation
void applyBilateralFilter(arma::mat& Z, double sigma_spatial, double sigma_range) {
    arma::mat Z_filtered = Z;
    int kernel_size = 5; // Adjust based on needs
    double sigma_spatial2 = 2 * sigma_spatial * sigma_spatial;
    double sigma_range2 = 2 * sigma_range * sigma_range;

    for (uint i = kernel_size; i < Z.n_rows - kernel_size; ++i) {
        for (uint j = kernel_size; j < Z.n_cols - kernel_size; ++j) {
            if (Z(i, j) == 0) continue;
            double sum = 0.0;
            double weight_sum = 0.0;
            for (int di = -kernel_size; di <= kernel_size; ++di) {
                for (int dj = -kernel_size; dj <= kernel_size; ++dj) {
                    int ni = i + di;
                    int nj = j + dj;
                    if (ni >= 0 && nj >= 0 && ni < Z.n_rows && nj < Z.n_cols && Z(ni, nj) > 0) {
                        double spatial_dist = di * di + dj * dj;
                        double range_dist = (Z(i, j) - Z(ni, nj)) * (Z(i, j) - Z(ni, nj));
                        double weight = exp(-spatial_dist / sigma_spatial2 - range_dist / sigma_range2);
                        sum += weight * Z(ni, nj);
                        weight_sum += weight;
                    }
                }
            }
            if (weight_sum > 0) {
                Z_filtered(i, j) = sum / weight_sum;
            }
        }
    }
    Z = Z_filtered;
}

void callback(const boost::shared_ptr<const sensor_msgs::PointCloud2>& in_pc2, const ImageConstPtr& in_image) {
    cv_bridge::CvImagePtr cv_ptr, color_pcl;
    try {
        cv_ptr = cv_bridge::toCvCopy(in_image, sensor_msgs::image_encodings::BGR8);
        color_pcl = cv_bridge::toCvCopy(in_image, sensor_msgs::image_encodings::BGR8);
    } catch (cv_bridge::Exception& e) {
        ROS_ERROR("cv_bridge exception: %s", e.what());
        return;
    }

    // Convert sensor_msgs::PointCloud2 to pcl::PointCloud<T>
    pcl::PCLPointCloud2 pcl_pc2;
    pcl_conversions::toPCL(*in_pc2, pcl_pc2);
    PointCloud::Ptr msg_pointCloud(new PointCloud);
    pcl::fromPCLPointCloud2(pcl_pc2, *msg_pointCloud);

    // Filter point cloud
    if (msg_pointCloud == NULL) return;

    PointCloud::Ptr cloud_in(new PointCloud);
    PointCloud::Ptr cloud_out(new PointCloud);
    std::vector<int> indices;
    pcl::removeNaNFromPointCloud(*msg_pointCloud, *cloud_in, indices);

    for (int i = 0; i < (int)cloud_in->points.size(); i++) {
        double distance = sqrt(cloud_in->points[i].x * cloud_in->points[i].x + cloud_in->points[i].y * cloud_in->points[i].y);
        if (distance < minlen || distance > maxlen) continue;
        cloud_out->push_back(cloud_in->points[i]);
    }

    // Adaptive statistical outlier removal
    pcl::StatisticalOutlierRemoval<pcl::PointXYZI> sor;
    sor.setInputCloud(cloud_out);
    sor.setMeanK(30); // Reduced for far-range sensitivity
    sor.setStddevMulThresh(0.8); // More permissive for far points
    sor.filter(*cloud_out);

    // Create range image
    Eigen::Affine3f sensorPose = (Eigen::Affine3f)Eigen::Translation3f(0.0f, 0.0f, 0.0f);
    rangeImage->createFromPointCloud(*cloud_out, pcl::deg2rad(angular_resolution_x), pcl::deg2rad(angular_resolution_y),
                                     pcl::deg2rad(max_angle_width), pcl::deg2rad(max_angle_height),
                                     sensorPose, coordinate_frame, 0.0f, 0.0f, 0);

    int cols_img = rangeImage->width;
    int rows_img = rangeImage->height;

    arma::mat Z(rows_img, cols_img, arma::fill::zeros);  // Range
    arma::mat Zz(rows_img, cols_img, arma::fill::zeros); // Height

    float max_depth = 0.0, min_depth = std::numeric_limits<float>::infinity();
    for (int i = 0; i < cols_img; ++i) {
        for (int j = 0; j < rows_img; ++j) {
            float r = rangeImage->getPoint(i, j).range;
            float zz = rangeImage->getPoint(i, j).z;
            if (std::isinf(r) || r < minlen || r > maxlen || std::isnan(zz)) continue;
            Z(j, i) = r;
            Zz(j, i) = zz;
            if (r > max_depth) max_depth = r;
            if (r < min_depth) min_depth = r;
        }
    }

    // Interpolation
    arma::vec X = arma::regspace(1, Z.n_cols);
    arma::vec Y = arma::regspace(1, Z.n_rows);
    arma::vec XI = arma::regspace(X.min(), 0.5, X.max()); // Finer horizontal resolution
    arma::vec YI = arma::regspace(Y.min(), 1.0 / interpol_value, Y.max()); // More vertical lines

    arma::mat ZI, ZzI;
    arma::interp2(X, Y, Z, XI, YI, ZI, "cubic"); // Use cubic interpolation
    arma::interp2(X, Y, Zz, XI, YI, ZzI, "cubic");

    // Apply bilateral filter to preserve edges
    applyBilateralFilter(ZI, 3.0, 0.5 * (max_depth - min_depth));

    arma::mat Zout = ZI;

    // Handle zeros in interpolation
    for (uint i = 0; i < ZI.n_rows; i++) {
        for (uint j = 0; j < ZI.n_cols; j++) {
            if (ZI(i, j) == 0) {
                if (i + interpol_value < ZI.n_rows) {
                    for (int k = 1; k <= interpol_value; k++) Zout(i + k, j) = 0;
                }
                if (i > interpol_value) {
                    for (int k = 1; k <= interpol_value; k++) Zout(i - k, j) = 0;
                }
            }
        }
    }
    ZI = Zout;

    // Adaptive interpolation for sparse regions
    double density_threshold = 0.03; // Adjusted for far-range sensitivity
    int max_window_size = 11; // Larger for sparse far regions
    int min_window_size = 3;

    for (uint i = 1; i < ZI.n_rows - 1; ++i) {
        for (uint j = 1; j < ZI.n_cols - 1; ++j) {
            if (ZI(i, j) == 0) {
                double weighted_sum = 0.0;
                double weight_total = 0.0;
                int valid_neighbors = 0;
                for (int di = -1; di <= 1; ++di) {
                    for (int dj = -1; dj <= 1; ++dj) {
                        int ni = i + di;
                        int nj = j + dj;
                        if (ni >= 0 && nj >= 0 && ni < ZI.n_rows && nj < ZI.n_cols && ZI(ni, nj) > 0) {
                            valid_neighbors++;
                        }
                    }
                }
                int window_size = (valid_neighbors < density_threshold * 9) ? max_window_size : min_window_size;
                for (int di = -window_size; di <= window_size; ++di) {
                    for (int dj = -window_size; dj <= window_size; ++dj) {
                        int ni = i + di;
                        int nj = j + dj;
                        if (ni >= 0 && nj >= 0 && ni < ZI.n_rows && nj < ZI.n_cols && ZI(ni, nj) > 0) {
                            double distance = std::sqrt(di * di + dj * dj);
                            double weight = 1.0 / (distance + 1e-6);
                            weighted_sum += ZI(ni, nj) * weight;
                            weight_total += weight;
                        }
                    }
                }
                if (weight_total > 0) ZI(i, j) = weighted_sum / weight_total;
            }
        }
    }

    // Edge-preserving gradient-based enhancement
    arma::mat Zenhanced = ZI;
    arma::mat grad_x = arma::zeros(ZI.n_rows, ZI.n_cols);
    arma::mat grad_y = arma::zeros(ZI.n_rows, ZI.n_cols);
    arma::mat grad_mag = arma::zeros(ZI.n_rows, ZI.n_cols);

    for (uint i = 1; i < ZI.n_rows - 1; ++i) {
        for (uint j = 1; j < ZI.n_cols - 1; ++j) {
            if (ZI(i, j) > 0) {
                grad_x(i, j) = (ZI(i, j + 1) - ZI(i, j - 1)) * 0.5;
                grad_y(i, j) = (ZI(i + 1, j) - ZI(i - 1, j)) * 0.5;
                grad_mag(i, j) = std::sqrt(grad_x(i, j) * grad_x(i, j) + grad_y(i, j) * grad_y(i, j));
            }
        }
    }

    double edge_threshold = 0.08 * arma::max(arma::max(grad_mag)); // Lowered for far-range edges
    for (uint i = 1; i < ZI.n_rows - 1; ++i) {
        for (uint j = 1; j < ZI.n_cols - 1; ++j) {
            if (grad_mag(i, j) > edge_threshold) {
                double weight = std::max(0.0, 1.0 - grad_mag(i, j) / edge_threshold);
                Zenhanced(i, j) = ZI(i, j) * weight + Zenhanced(i, j) * (1 - weight);
            }
        }
    }
    ZI = Zenhanced;

    // Variance-based filtering
    if (f_pc) {
        for (uint i = 0; i < ((ZI.n_rows - 1) / interpol_value); i += 1) {
            for (uint j = 0; j < ZI.n_cols - 5; j += 1) {
                double promedio = 0;
                double varianza = 0;
                for (uint k = 0; k < interpol_value; k += 1) {
                    promedio += ZI((i * interpol_value) + k, j);
                }
                promedio /= interpol_value;
                for (uint l = 0; l < interpol_value; l++) {
                    varianza += pow((ZI((i * interpol_value) + l, j) - promedio), 2.0);
                }
                varianza = sqrt(varianza / interpol_value);
                if (varianza > max_var) {
                    for (uint m = 0; m < interpol_value; m++) {
                        Zout((i * interpol_value) + m, j) = 0;
                    }
                }
            }
        }
        ZI = Zout;
    }

    // Reconstruct 3D point cloud
    PointCloud::Ptr point_cloud(new PointCloud);
    PointCloud::Ptr cloud(new PointCloud);
    point_cloud->width = ZI.n_cols;
    point_cloud->height = ZI.n_rows;
    point_cloud->is_dense = false;
    point_cloud->points.resize(point_cloud->width * point_cloud->height);

    int num_pc = 0;
    for (uint i = 0; i < ZI.n_rows - interpol_value; i += 1) {
        for (uint j = 0; j < ZI.n_cols; j += 1) {
            float ang = M_PI - ((2.0 * M_PI * j) / (ZI.n_cols));
            if (ang < min_FOV - M_PI / 2.0 || ang > max_FOV - M_PI / 2.0) continue;
            if (Zout(i, j) == 0) continue;

            float pc_modulo = Zout(i, j);
            float pc_x = sqrt(pow(pc_modulo, 2) - pow(ZzI(i, j), 2)) * cos(ang);
            float pc_y = sqrt(pow(pc_modulo, 2) - pow(ZzI(i, j), 2)) * sin(ang);
            float ang_x_lidar = 0.6 * M_PI / 180.0;

            Eigen::MatrixXf Lidar_matrix(3, 3);
            Eigen::MatrixXf result(3, 1);
            Lidar_matrix << cos(ang_x_lidar), 0, sin(ang_x_lidar),
                            0, 1, 0,
                            -sin(ang_x_lidar), 0, cos(ang_x_lidar);
            result << pc_x, pc_y, ZzI(i, j);
            result = Lidar_matrix * result;

            point_cloud->points[num_pc].x = result(0);
            point_cloud->points[num_pc].y = result(1);
            point_cloud->points[num_pc].z = result(2);
            cloud->push_back(point_cloud->points[num_pc]);
            num_pc++;
        }
    }

    // Project LiDAR points onto camera image
    Eigen::MatrixXf RTlc(4, 4);
    RTlc << Rlc(0, 0), Rlc(0, 1), Rlc(0, 2), Tlc(0),
            Rlc(1, 0), Rlc(1, 1), Rlc(1, 2), Tlc(1),
            Rlc(2, 0), Rlc(2, 1), Rlc(2, 2), Tlc(2),
            0, 0, 0, 1;

    int size_inter_Lidar = (int)cloud->points.size();
    unsigned int cols = in_image->width;
    unsigned int rows = in_image->height;

    pcl::PointCloud<pcl::PointXYZRGB>::Ptr pc_color(new pcl::PointCloud<pcl::PointXYZRGB>);
    for (int i = 0; i < size_inter_Lidar; i++) {
        Eigen::MatrixXf pc_matrix(4, 1);
        pc_matrix << -cloud->points[i].y, -cloud->points[i].z, cloud->points[i].x, 1.0;
        Eigen::MatrixXf Lidar_cam = Mc * (RTlc * pc_matrix);
        int px_data = (int)(Lidar_cam(0, 0) / Lidar_cam(2, 0));
        int py_data = (int)(Lidar_cam(1, 0) / Lidar_cam(2, 0));

        if (px_data < 0 || px_data >= cols || py_data < 0 || py_data >= rows) continue;

        // Depth-based color mapping
        double depth = sqrt(pow(cloud->points[i].x, 2) + pow(cloud->points[i].y, 2) + pow(cloud->points[i].z, 2));
        int color_r = (int)(255 * (depth / maxlen));
        int color_g = (int)(255 * (1.0 - depth / maxlen));
        int color_b = (int)(255 * (cloud->points[i].z / 10.0));
        if (color_b > 255) color_b = 255;

        cv::Vec3b &color = color_pcl->image.at<cv::Vec3b>(py_data, px_data);
        pcl::PointXYZRGB point;
        point.x = cloud->points[i].x;
        point.y = cloud->points[i].y;
        point.z = cloud->points[i].z;
        point.r = color[2]; // Use camera image color
        point.g = color[1];
        point.b = color[0];
        pc_color->points.push_back(point);

        cv::circle(cv_ptr->image, cv::Point(px_data, py_data), 1, CV_RGB(color_r, color_g, color_b), cv::FILLED);
    }

    pc_color->is_dense = true;
    pc_color->width = (int)pc_color->points.size();
    pc_color->height = 1;
    pc_color->header.frame_id = "velodyne";

    pcOnimg_pub.publish(cv_ptr->toImageMsg());
    pc_pub.publish(pc_color);
}

int main(int argc, char** argv) {
    ros::init(argc, argv, "pontCloudOntImage");
    ros::NodeHandle nh;

    // Load parameters
    nh.getParam("/maxlen", maxlen);
    nh.getParam("/minlen", minlen);
    nh.getParam("/max_ang_FOV", max_FOV);
    nh.getParam("/min_ang_FOV", min_FOV);
    nh.getParam("/pcTopic", pcTopic);
    nh.getParam("/imgTopic", imgTopic);
    nh.getParam("/max_var", max_var);
    nh.getParam("/filter_output_pc", f_pc);
    nh.getParam("/x_resolution", angular_resolution_x);
    nh.getParam("/y_interpolation", interpol_value);
    nh.getParam("/ang_Y_resolution", angular_resolution_y);

    XmlRpc::XmlRpcValue param;
    nh.getParam("/matrix_file/tlc", param);
    Tlc << (double)param[0], (double)param[1], (double)param[2];
    nh.getParam("/matrix_file/rlc", param);
    Rlc << (double)param[0], (double)param[1], (double)param[2],
           (double)param[3], (double)param[4], (double)param[5],
           (double)param[6], (double)param[7], (double)param[8];
    nh.getParam("/matrix_file/camera_matrix", param);
    Mc << (double)param[0], (double)param[1], (double)param[2], (double)param[3],
          (double)param[4], (double)param[5], (double)param[6], (double)param[7],
          (double)param[8], (double)param[9], (double)param[10], (double)param[11];

    message_filters::Subscriber<PointCloud2> pc_sub(nh, pcTopic, 1);
    message_filters::Subscriber<Image> img_sub(nh, imgTopic, 1);
    typedef sync_policies::ApproximateTime<PointCloud2, Image> MySyncPolicy;
    Synchronizer<MySyncPolicy> sync(MySyncPolicy(10), pc_sub, img_sub);
    sync.registerCallback(boost::bind(&callback, _1, _2));
    pcOnimg_pub = nh.advertise<sensor_msgs::Image>("/pcOnImage_image", 1);
    rangeImage = boost::shared_ptr<pcl::RangeImageSpherical>(new pcl::RangeImageSpherical);
    pc_pub = nh.advertise<PointCloud>("/points2", 1);

    ros::spin();
    return 0;
}
