#include <ros/ros.h>
#include <sensor_msgs/Image.h>
#include <sensor_msgs/PointCloud2.h>
#include <cv_bridge/cv_bridge.h>
#include <pcl_ros/point_cloud.h>
#include <pcl_conversions/pcl_conversions.h>
#include <image_transport/image_transport.h>
#include <pcl/point_types.h>
#include <pcl/range_image/range_image_spherical.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl/filters/statistical_outlier_removal.h>
#include <opencv2/imgproc/imgproc.hpp>
#include <armadillo>
#include <message_filters/subscriber.h>
#include <message_filters/synchronizer.h>
#include <message_filters/sync_policies/approximate_time.h>
#include <Eigen/Dense>
#include <chrono>
#include <stdexcept>

using namespace Eigen;
using namespace sensor_msgs;
using namespace message_filters;
using namespace std;
using namespace arma;

typedef pcl::PointCloud<pcl::PointXYZI> PointCloud;

// Global Publishers
ros::Publisher pcOnimg_pub;
ros::Publisher pc_pub;

// Configuration Parameters
struct Config {
    float maxlen = 100.0f;        // Max LiDAR distance
    float minlen = 0.01f;         // Min LiDAR distance
    float max_FOV = 3.0f;         // Max camera FOV (radians)
    float min_FOV = 0.4f;         // Min camera FOV (radians)
    float angular_resolution_x = 0.5f;
    float angular_resolution_y = 2.1f;
    float max_angle_width = 360.0f;
    float max_angle_height = 180.0f;
    float max_depth = 100.0f;
    float min_depth = 8.0f;
    double max_var = 50.0;
    float interpol_value = 20.0f;
    bool filter_pc = true;
    float voxel_leaf_size = 0.1f;
    int sor_mean_k = 50;
    float sor_stddev = 1.0f;
    std::string imgTopic = "/camera/color/image_raw";
    std::string pcTopic = "/velodyne_points";
};

// Calibration Matrices
Eigen::MatrixXf Tlc(3, 1); // Translation matrix lidar-camera
Eigen::MatrixXf Rlc(3, 3); // Rotation matrix lidar-camera
Eigen::MatrixXf Mc(3, 4);  // Camera calibration matrix

// Range Image
boost::shared_ptr<pcl::RangeImageSpherical> rangeImage;
pcl::RangeImage::CoordinateFrame coordinate_frame = pcl::RangeImage::LASER_FRAME;

// Function to load ROS parameters
void loadParameters(ros::NodeHandle& nh, Config& cfg) {
    nh.param("/maxlen", cfg.maxlen, cfg.maxlen);
    nh.param("/minlen", cfg.minlen, cfg.minlen);
    nh.param("/max_ang_FOV", cfg.max_FOV, cfg.max_FOV);
    nh.param("/min_ang_FOV", cfg.min_FOV, cfg.min_FOV);
    nh.param("/pcTopic", cfg.pcTopic, cfg.pcTopic);
    nh.param("/imgTopic", cfg.imgTopic, cfg.imgTopic);
    nh.param("/max_var", cfg.max_var, cfg.max_var);
    nh.param("/filter_output_pc", cfg.filter_pc, cfg.filter_pc);
    nh.param("/x_resolution", cfg.angular_resolution_x, cfg.angular_resolution_x);
    nh.param("/y_interpolation", cfg.interpol_value, cfg.interpol_value);
    nh.param("/ang_Y_resolution", cfg.angular_resolution_y, cfg.angular_resolution_y);
    nh.param("/voxel_leaf_size", cfg.voxel_leaf_size, cfg.voxel_leaf_size);
    nh.param("/sor_mean_k", cfg.sor_mean_k, cfg.sor_mean_k);
    nh.param("/sor_stddev", cfg.sor_stddev, cfg.sor_stddev);

    XmlRpc::XmlRpcValue param;
    if (nh.getParam("/matrix_file/tlc", param) && param.size() == 3) {
        Tlc << static_cast<double>(param[0]), static_cast<double>(param[1]), static_cast<double>(param[2]);
        ROS_INFO("Loaded Tlc: \n%s", Tlc.format(IOFormat(4, 0, ", ", "\n", "[", "]")).c_str());
    } else {
        ROS_ERROR("Failed to load Tlc matrix");
        throw std::runtime_error("Invalid Tlc matrix");
    }

    if (nh.getParam("/matrix_file/rlc", param) && param.size() == 9) {
        Rlc << static_cast<double>(param[0]), static_cast<double>(param[1]), static_cast<double>(param[2]),
               static_cast<double>(param[3]), static_cast<double>(param[4]), static_cast<double>(param[5]),
               static_cast<double>(param[6]), static_cast<double>(param[7]), static_cast<double>(param[8]);
        ROS_INFO("Loaded Rlc: \n%s", Rlc.format(IOFormat(4, 0, ", ", "\n", "[", "]")).c_str());
    } else {
        ROS_ERROR("Failed to load Rlc matrix");
        throw std::runtime_error("Invalid Rlc matrix");
    }

    if (nh.getParam("/matrix_file/camera_matrix", param) && param.size() == 12) {
        Mc << static_cast<double>(param[0]), static_cast<double>(param[1]), static_cast<double>(param[2]), static_cast<double>(param[3]),
              static_cast<double>(param[4]), static_cast<double>(param[5]), static_cast<double>(param[6]), static_cast<double>(param[7]),
              static_cast<double>(param[8]), static_cast<double>(param[9]), static_cast<double>(param[10]), static_cast<double>(param[11]);
        ROS_INFO("Loaded Mc: \n%s", Mc.format(IOFormat(4, 0, ", ", "\n", "[", "]")).c_str());
    } else {
        ROS_ERROR("Failed to load camera matrix");
        throw std::runtime_error("Invalid camera matrix");
    }
}

// Function to filter point cloud
void filterPointCloud(const PointCloud::Ptr& cloud_in, PointCloud::Ptr& cloud_out, const Config& cfg) {
    // Remove NaN points
    std::vector<int> indices;
    pcl::removeNaNFromPointCloud(*cloud_in, *cloud_out, indices);
    ROS_DEBUG("Removed NaN points, remaining: %zu", cloud_out->points.size());

    // Distance-based filtering
    PointCloud::Ptr temp_cloud(new PointCloud);
    for (const auto& point : cloud_out->points) {
        double distance = std::sqrt(point.x * point.x + point.y * point.y);
        if (distance >= cfg.minlen && distance <= cfg.maxlen) {
            temp_cloud->push_back(point);
        }
    }
    cloud_out->swap(*temp_cloud);
    ROS_DEBUG("After distance filter, points: %zu", cloud_out->points.size());

    // Voxel Grid Downsampling
    pcl::VoxelGrid<pcl::PointXYZI> voxel;
    voxel.setInputCloud(cloud_out);
    voxel.setLeafSize(cfg.voxel_leaf_size, cfg.voxel_leaf_size, cfg.voxel_leaf_size);
    voxel.filter(*temp_cloud);
    cloud_out->swap(*temp_cloud);
    ROS_DEBUG("After voxel filter, points: %zu", cloud_out->points.size());

    // Statistical Outlier Removal
    pcl::StatisticalOutlierRemoval<pcl::PointXYZI> sor;
    sor.setInputCloud(cloud_out);
    sor.setMeanK(cfg.sor_mean_k);
    sor.setStddevMulThresh(cfg.sor_stddev);
    sor.filter(*temp_cloud);
    cloud_out->swap(*temp_cloud);
    ROS_DEBUG("After SOR filter, points: %zu", cloud_out->points.size());
}

// Function to create range image
void createRangeImage(const PointCloud::Ptr& cloud, const Config& cfg) {
    Eigen::Affine3f sensorPose = Eigen::Affine3f::Identity();
    rangeImage->createFromPointCloud(
        *cloud,
        pcl::deg2rad(cfg.angular_resolution_x),
        pcl::deg2rad(cfg.angular_resolution_y),
        pcl::deg2rad(cfg.max_angle_width),
        pcl::deg2rad(cfg.max_angle_height),
        sensorPose,
        coordinate_frame,
        0.0f,
        0.0f,
        0
    );
    ROS_DEBUG("Created range image: %d x %d", rangeImage->width, rangeImage->height);
}

// Function to interpolate depth image
void interpolateDepthImage(const Config& cfg, arma::mat& ZI, arma::mat& ZzI) {
    arma::mat Z(rangeImage->height, rangeImage->width, fill::zeros);
    arma::mat Zz(rangeImage->height, rangeImage->width, fill::zeros);

    for (int i = 0; i < rangeImage->width; ++i) {
        for (int j = 0; j < rangeImage->height; ++j) {
            float r = rangeImage->getPoint(i, j).range;
            float zz = rangeImage->getPoint(i, j).z;
            if (std::isinf(r) || std::isnan(zz) || r < cfg.minlen || r > cfg.maxlen) {
                continue;
            }
            Z(j, i) = r;
            Zz(j, i) = zz;
        }
    }

    arma::vec X = arma::regspace(1, Z.n_cols);
    arma::vec Y = arma::regspace(1, Z.n_rows);
    arma::vec XI = arma::regspace(X.min(), 1.0, X.max());
    arma::vec YI = arma::regspace(Y.min(), 1.0 / cfg.interpol_value, Y.max());

    arma::interp2(X, Y, Z, XI, YI, ZI, "linear");
    arma::interp2(X, Y, Zz, XI, YI, ZzI, "linear");

    // Adaptive interpolation for missing data
    arma::mat Zout = ZI;
    double density_threshold = 0.05;
    int max_window_size = 9;
    int min_window_size = 3;

    for (uint i = 1; i < ZI.n_rows - 1; ++i) {
        for (uint j = 1; j < ZI.n_cols - 1; ++j) {
            if (ZI(i, j) == 0) {
                int valid_neighbors = 0;
                for (int di = -1; di <= 1; ++di) {
                    for (int dj = -1; dj <= 1; ++dj) {
                        int ni = i + di;
                        int nj = j + dj;
                        if (ni >= 0 && nj >= 0 && ni < ZI.n_rows && nj < ZI.n_cols && ZI(ni, nj) > 0) {
                            valid_neighbors++;
                        }
                    }
                }

                int window_size = (valid_neighbors < density_threshold * 9) ? max_window_size : min_window_size;
                double weighted_sum = 0.0;
                double weight_total = 0.0;

                for (int di = -window_size; di <= window_size; ++di) {
                    for (int dj = -window_size; dj <= window_size; ++dj) {
                        int ni = i + di;
                        int nj = j + dj;
                        if (ni >= 0 && nj >= 0 && ni < ZI.n_rows && nj < ZI.n_cols && ZI(ni, nj) > 0) {
                            double distance = std::sqrt(di * di + dj * dj);
                            double weight = 1.0 / (distance + 1e-6);
                            weighted_sum += ZI(ni, nj) * weight;
                            weight_total += weight;
                        }
                    }
                }

                if (weight_total > 0) {
                    ZI(i, j) = weighted_sum / weight_total;
                }
            }
        }
    }

    // Edge preservation
    arma::mat grad_x = arma::zeros(ZI.n_rows, ZI.n_cols);
    arma::mat grad_y = arma::zeros(ZI.n_rows, ZI.n_cols);
    arma::mat grad_mag = arma::zeros(ZI.n_rows, ZI.n_cols);

    for (uint i = 1; i < ZI.n_rows - 1; ++i) {
        for (uint j = 1; j < ZI.n_cols - 1; ++j) {
            if (ZI(i, j) > 0) {
                grad_x(i, j) = (ZI(i, j + 1) - ZI(i, j - 1)) * 0.5;
                grad_y(i, j) = (ZI(i + 1, j) - ZI(i - 1, j)) * 0.5;
                grad_mag(i, j) = std::sqrt(grad_x(i, j) * grad_x(i, j) + grad_y(i, j) * grad_y(i, j));
            }
        }
    }

    double edge_threshold = 0.1 * arma::max(arma::max(grad_mag));
    arma::mat Zenhanced = ZI;
    for (uint i = 1; i < ZI.n_rows - 1; ++i) {
        for (uint j = 1; j < ZI.n_cols - 1; ++j) {
            if (grad_mag(i, j) > edge_threshold) {
                double weight = std::max(0.0, 1.0 - grad_mag(i, j) / edge_threshold);
                Zenhanced(i, j) = ZI(i, j) * weight + Zenhanced(i, j) * (1 - weight);
            }
        }
    }
    ZI = Zenhanced;

    if (cfg.filter_pc) {
        // Variance-based filtering
        for (uint i = 0; i < (ZI.n_rows - 1) / cfg.interpol_value; ++i) {
            for (uint j = 0; j < ZI.n_cols - 5; ++j) {
                double promedio = 0;
                double varianza = 0;
                for (uint k = 0; k < cfg.interpol_value; ++k) {
                    promedio += ZI(i * cfg.interpol_value + k, j);
                }
                promedio /= cfg.interpol_value;

                for (uint l = 0; l < cfg.interpol_value; ++l) {
                    varianza += std::pow(ZI(i * cfg.interpol_value + l, j) - promedio, 2.0);
                }
                if (varianza > cfg.max_var) {
                    for (uint m = 0; m < cfg.interpol_value; ++m) {
                        Zout(i * cfg.interpol_value + m, j) = 0;
                    }
                }
            }
        }
        ZI = Zout;
    }
}

// Function to convert range image to point cloud
void rangeImageToPointCloud(const arma::mat& ZI, const arma::mat& ZzI, const Config& cfg, PointCloud::Ptr& point_cloud) {
    point_cloud->width = ZI.n_cols;
    point_cloud->height = ZI.n_rows;
    point_cloud->is_dense = false;
    point_cloud->points.resize(point_cloud->width * point_cloud->height);

    int num_pc = 0;
    Eigen::Matrix3f Lidar_matrix;
    float ang_x_lidar = 0.6 * M_PI / 180.0;
    Lidar_matrix << std::cos(ang_x_lidar), 0, std::sin(ang_x_lidar),
                    0, 1, 0,
                    -std::sin(ang_x_lidar), 0, std::cos(ang_x_lidar);

    for (uint i = 0; i < ZI.n_rows - cfg.interpol_value; ++i) {
        for (uint j = 0; j < ZI.n_cols; ++j) {
            float ang = M_PI - (2.0 * M_PI * j) / ZI.n_cols;
            if (ang < cfg.min_FOV - M_PI / 2.0 || ang > cfg.max_FOV - M_PI / 2.0) {
                continue;
            }
            if (ZI(i, j) == 0) {
                continue;
            }

            float pc_modulo = ZI(i, j);
            float pc_x = std::sqrt(pc_modulo * pc_modulo - ZzI(i, j) * ZzI(i, j)) * std::cos(ang);
            float pc_y = std::sqrt(pc_modulo * pc_modulo - ZzI(i, j) * ZzI(i, j)) * std::sin(ang);

            Eigen::Vector3f result(pc_x, pc_y, ZzI(i, j));
            result = Lidar_matrix * result;

            point_cloud->points[num_pc].x = result(0);
            point_cloud->points[num_pc].y = result(1);
            point_cloud->points[num_pc].z = result(2);
            num_pc++;
        }
    }
    point_cloud->points.resize(num_pc);
    ROS_DEBUG("Converted to point cloud with %d points", num_pc);
}

// Callback function
void callback(const PointCloud2ConstPtr& in_pc2, const ImageConstPtr& in_image, const Config& cfg) {
    auto start = std::chrono::high_resolution_clock::now();

    // Convert image to OpenCV format
    cv_bridge::CvImagePtr cv_ptr, color_pcl;
    try {
        cv_ptr = cv_bridge::toCvCopy(in_image, sensor_msgs::image_encodings::BGR8);
        color_pcl = cv_bridge::toCvCopy(in_image, sensor_msgs::image_encodings::BGR8);
    } catch (cv_bridge::Exception& e) {
        ROS_ERROR("cv_bridge exception: %s", e.what());
        return;
    }

    // Convert PointCloud2 to PCL
    pcl::PCLPointCloud2 pcl_pc2;
    pcl_conversions::toPCL(*in_pc2, pcl_pc2);
    PointCloud::Ptr msg_pointCloud(new PointCloud);
    pcl::fromPCLPointCloud2(pcl_pc2, *msg_pointCloud);
    if (msg_pointCloud->empty()) {
        ROS_WARN("Empty point cloud received");
        return;
    }

    // Filter point cloud
    PointCloud::Ptr cloud_filtered(new PointCloud);
    filterPointCloud(msg_pointCloud, cloud_filtered, cfg);

    // Create range image
    createRangeImage(cloud_filtered, cfg);

    // Interpolate depth image
    arma::mat ZI, ZzI;
    interpolateDepthImage(cfg, ZI, ZzI);

    // Convert range image to point cloud
    PointCloud::Ptr point_cloud(new PointCloud);
    rangeImageToPointCloud(ZI, ZzI, cfg, point_cloud);

    // Project point cloud onto image
    Eigen::Matrix4f RTlc;
    RTlc << Rlc(0, 0), Rlc(0, 1), Rlc(0, 2), Tlc(0),
            Rlc(1, 0), Rlc(1, 1), Rlc(1, 2), Tlc(1),
            Rlc(2, 0), Rlc(2, 1), Rlc(2, 2), Tlc(2),
            0, 0, 0, 1;

    pcl::PointCloud<pcl::PointXYZRGB>::Ptr pc_color(new pcl::PointCloud<pcl::PointXYZRGB>);
    Eigen::Matrix4f pc_matrix = Eigen::Matrix4f::Zero();
    pc_matrix(3, 0) = 1.0;

    unsigned int cols = in_image->width;
    unsigned int rows = in_image->height;

    for (size_t i = 0; i < point_cloud->points.size(); ++i) {
        pc_matrix(0, 0) = -point_cloud->points[i].y;
        pc_matrix(1, 0) = -point_cloud->points[i].z;
        pc_matrix(2, 0) = point_cloud->points[i].x;

        Eigen::Vector3f Lidar_cam = Mc * (RTlc * pc_matrix);
        int px_data = static_cast<int>(Lidar_cam(0) / Lidar_cam(2));
        int py_data = static_cast<int>(Lidar_cam(1) / Lidar_cam(2));

        if (px_data < 0 || px_data >= cols || py_data < 0 || py_data >= rows) {
            continue;
        }

        int color_dis_x = static_cast<int>(255 * (point_cloud->points[i].x / cfg.maxlen));
        int color_dis_z = static_cast<int>(255 * (point_cloud->points[i].x / 10.0));
        if (color_dis_z > 255) color_dis_z = 255;

        cv::Vec3b& color = color_pcl->image.at<cv::Vec3b>(py_data, px_data);
        pcl::PointXYZRGB point;
        point.x = point_cloud->points[i].x;
        point.y = point_cloud->points[i].y;
        point.z = point_cloud->points[i].z;
        point.r = color[2];
        point.g = color[1];
        point.b = color[0];
        pc_color->points.push_back(point);

        cv::circle(cv_ptr->image, cv::Point(px_data, py_data), 1, CV_RGB(255 - color_dis_x, color_dis_z, color_dis_x), cv::FILLED);
    }

    pc_color->is_dense = true;
    pc_color->width = pc_color->points.size();
    pc_color->height = 1;
    pc_color->header.frame_id = "velodyne";

    // Publish results
    pcOnimg_pub.publish(cv_ptr->toImageMsg());
    pc_pub.publish(pc_color);

    auto end = std::chrono::high_resolution_clock::now();
    ROS_DEBUG("Callback processing time: %ld ms", std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count());
}

int main(int argc, char** argv) {
    ros::init(argc, argv, "lidar_camera_fusion");
    ros::NodeHandle nh;

    Config cfg;
    try {
        loadParameters(nh, cfg);
    } catch (const std::exception& e) {
        ROS_ERROR("Initialization failed: %s", e.what());
        return 1;
    }

    rangeImage = boost::shared_ptr<pcl::RangeImageSpherical>(new pcl::RangeImageSpherical);
    pcOnimg_pub = nh.advertise<sensor_msgs::Image>("/pcOnImage_image", 1);
    pc_pub = nh.advertise<PointCloud>("/points2", 1);

    message_filters::Subscriber<PointCloud2> pc_sub(nh, cfg.pcTopic, 1);
    message_filters::Subscriber<Image> img_sub(nh, cfg.imgTopic, 1);

    typedef sync_policies::ApproximateTime<PointCloud2, Image> MySyncPolicy;
    Synchronizer<MySyncPolicy> sync(MySyncPolicy(10), pc_sub, img_sub);
    sync.registerCallback(boost::bind(&callback, _1, _2, cfg));

    ROS_INFO("LiDAR-Camera fusion node started");
    ros::spin();
    return 0;
}
