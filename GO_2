#include <ros/ros.h>
#include <sensor_msgs/Image.h>
#include <cv_bridge/cv_bridge.h>
#include <pcl_ros/point_cloud.h>
#include <pcl_conversions/pcl_conversions.h>
#include <image_transport/image_transport.h>
#include <pcl/point_types.h>
#include <pcl/range_image/range_image.h>
#include <pcl/range_image/range_image_spherical.h>
#include <pcl/filters/filter.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl/impl/point_types.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <armadillo>
#include <message_filters/subscriber.h>
#include <message_filters/time_synchronizer.h>
#include <message_filters/synchronizer.h>
#include <message_filters/sync_policies/approximate_time.h>
#include <pcl/filters/statistical_outlier_removal.h>
#include <Eigen/Dense>
#include <chrono>
#include <sstream>

using namespace Eigen;
using namespace sensor_msgs;
using namespace message_filters;
using namespace std;
using namespace arma;

typedef pcl::PointCloud<pcl::PointXYZI> PointCloud;

// Publisher
ros::Publisher pcOnimg_pub;
ros::Publisher pc_pub;
ros::Publisher range_image_pub;

float maxlen = 100.0;
float minlen = 0.01;
float max_FOV = 3.0;
float min_FOV = 0.4;
float angular_resolution_x = 0.5f;
float angular_resolution_y = 2.1f;
float max_angle_width = 360.0f;
float max_angle_height = 180.0f;
float z_max = 100.0f;
float z_min = 100.0f;
float max_depth = 100.0;
float min_depth = 8.0;
double max_var = 50.0;
float interpol_value = 20.0;
float far_depth_threshold = 50.0f;
float far_interpol_scale = 0.03f; // 33x denser for far regions
float interpol_steepness = 0.4f;  // Sharper transition
bool f_pc = true;
std::string imgTopic = "/camera/color/image_raw";
std::string pcTopic = "/velodyne_points";

Eigen::MatrixXf Tlc(3, 1);
Eigen::MatrixXf Rlc(3, 3);
Eigen::MatrixXf Mc(3, 4);
boost::shared_ptr<pcl::RangeImageSpherical> rangeImage;
pcl::RangeImage::CoordinateFrame coordinate_frame = pcl::RangeImage::LASER_FRAME;

void callback(const boost::shared_ptr<const sensor_msgs::PointCloud2>& in_pc2, const ImageConstPtr& in_image) {
    cv_bridge::CvImagePtr cv_ptr, color_pcl;
    try {
        cv_ptr = cv_bridge::toCvCopy(in_image, sensor_msgs::image_encodings::BGR8);
        color_pcl = cv_bridge::toCvCopy(in_image, sensor_msgs::image_encodings::BGR8);
    } catch (cv_bridge::Exception& e) {
        ROS_ERROR("cv_bridge exception: %s", e.what());
        return;
    }

    pcl::PCLPointCloud2 pcl_pc2;
    pcl_conversions::toPCL(*in_pc2, pcl_pc2);
    PointCloud::Ptr msg_pointCloud(new PointCloud);
    pcl::fromPCLPointCloud2(pcl_pc2, *msg_pointCloud);

    if (msg_pointCloud == NULL) return;

    PointCloud::Ptr cloud_in(new PointCloud);
    PointCloud::Ptr cloud_out(new PointCloud);
    std::vector<int> indices;
    pcl::removeNaNFromPointCloud(*msg_pointCloud, *cloud_in, indices);

    for (int i = 0; i < (int)cloud_in->points.size(); i++) {
        double distance = sqrt(cloud_in->points[i].x * cloud_in->points[i].x + cloud_in->points[i].y * cloud_in->points[i].y);
        if (distance < minlen || distance > maxlen)
            continue;
        cloud_out->push_back(cloud_in->points[i]);
    }

    Eigen::Affine3f sensorPose = (Eigen::Affine3f)Eigen::Translation3f(0.0f, 0.0f, 0.0f);
    rangeImage->pcl::RangeImage::createFromPointCloud(*cloud_out, pcl::deg2rad(angular_resolution_x), pcl::deg2rad(angular_resolution_y),
                                                      pcl::deg2rad(max_angle_width), pcl::deg2rad(max_angle_height),
                                                      sensorPose, coordinate_frame, 0.0f, 0.0f, 0);

    int cols_img = rangeImage->width;
    int rows_img = rangeImage->height;

    arma::mat Z;
    arma::mat Zz;
    Z.zeros(rows_img, cols_img);
    Zz.zeros(rows_img, cols_img);

    Eigen::MatrixXf ZZei(rows_img, cols_img);

    for (int i = 0; i < cols_img; ++i) {
        for (int j = 0; j < rows_img; ++j) {
            float r = rangeImage->getPoint(static_cast<int>(i), static_cast<int>(j)).range;
            float zz = rangeImage->getPoint(static_cast<int>(i), static_cast<int>(j)).z;
            float ang = M_PI - (2.0 * M_PI * i) / cols_img; // Approximate angular position
            if (std::isinf(r) || std::isnan(zz) || r < minlen * 1.1 || r > maxlen || ang < min_FOV - M_PI / 2.0 || ang > max_FOV - M_PI / 2.0) {
                continue; // Stricter noise filtering
            }
            Z.at(j, i) = r;
            Zz.at(j, i) = zz;
        }
    }

    ////////////////////////////////////////////// interpolation
    //============================================================================================================

    arma::vec X = arma::regspace(1, Z.n_cols);
    arma::vec Y = arma::regspace(1, Z.n_rows);

    // Depth-dependent step size for far-range densification
    auto compute_step_size = [&](double depth) {
        if (depth <= far_depth_threshold) {
            return 1.0 / interpol_value;
        }
        double t = (depth - far_depth_threshold) * interpol_steepness;
        double scale = far_interpol_scale / (1.0 + std::exp(-t));
        return scale;
    };

    double min_step = compute_step_size(maxlen);
    arma::vec XI = arma::regspace(X.min(), 1.0, X.max());
    arma::vec YI = arma::regspace(Y.min(), min_step, Y.max());

    arma::mat ZI_near;
    arma::mat ZI;
    arma::mat ZzI;
    arma::interp2(X, Y, Z, XI, YI, ZI, "linear");
    arma::interp2(X, Y, Zz, XI, YI, ZzI, "linear");

    ROS_INFO("ZI dimensions after interp2: %d x %d", ZI.n_rows, ZI.n_cols);

    // Gaussian interpolation for far regions with noise control
    double density_threshold = 0.1;
    int max_window_size = 11;
    int min_window_size = 3;
    arma::mat Zout = ZI;

    for (unsigned int i = 1; i < ZI.n_rows - 1; ++i) {
        for (unsigned int j = 1; j < ZI.n_cols - 1; ++j) {
            if (ZI(i, j) == 0 || ZI(i, j) > far_depth_threshold) {
                int valid_neighbors = 0;
                for (int di = -1; di <= 1; ++di) {
                    for (int dj = -1; dj <= 1; ++dj) {
                        unsigned int ni = i + di;
                        unsigned int nj = j + dj;
                        if (ni < ZI.n_rows && nj < ZI.n_cols && ZI(ni, nj) > 0 && ZI(ni, nj) < maxlen * 1.1) {
                            valid_neighbors++;
                        }
                    }
                }

                int window_size = (valid_neighbors < density_threshold * 9 || ZI(i, j) > far_depth_threshold) ?
                                  max_window_size : min_window_size;
                double weighted_sum = 0.0;
                double weight_total = 0.0;

                for (int di = -window_size; di <= window_size; ++di) {
                    for (int dj = -window_size; dj <= window_size; ++dj) {
                        unsigned int ni = i + di;
                        unsigned int nj = j + dj;
                        if (ni < ZI.n_rows && nj < ZI.n_cols && ZI(ni, nj) > 0 && ZI(ni, nj) < maxlen * 1.1) {
                            double distance = std::sqrt(di * di + dj * dj);
                            double weight = ZI(ni, nj) > far_depth_threshold ? 2.0 / (distance + 1e-6) : 1.0 / (distance + 1e-6);
                            weighted_sum += ZI(ni, nj) * weight;
                            weight_total += weight;
                        }
                    }
                }

                if (weight_total > 0 && valid_neighbors > 1) {
                    Zout(i, j) = weighted_sum / weight_total;
                }
            }
        }
    }
    ZI = Zout;

    // Original edge preservation
    arma::mat Zenhanced = ZI;
    arma::mat grad_x = arma::zeros(ZI.n_rows, ZI.n_cols);
    arma::mat grad_y = arma::zeros(ZI.n_rows, ZI.n_cols);
    arma::mat grad_mag = arma::zeros(ZI.n_rows, ZI.n_cols);

    for (unsigned int i = 1; i < ZI.n_rows - 1; ++i) {
        for (unsigned int j = 1; j < ZI.n_cols - 1; ++j) {
            if (ZI(i, j) > 0) {
                grad_x(i, j) = (ZI(i, j + 1) - ZI(i, j - 1)) * 0.5;
                grad_y(i, j) = (ZI(i + 1, j) - ZI(i - 1, j)) * 0.5;
                grad_mag(i, j) = std::sqrt(grad_x(i, j) * grad_x(i, j) + grad_y(i, j) * grad_y(i, j));
            }
        }
    }

    double edge_threshold = 0.1 * arma::max(arma::max(grad_mag));
    for (unsigned int i = 1; i < ZI.n_rows - 1; ++i) {
        for (unsigned int j = 1; j < ZI.n_cols - 1; ++j) {
            if (grad_mag(i, j) > edge_threshold) {
                double weight = std::max(0.0, 1.0 - grad_mag(i, j) / edge_threshold);
                Zenhanced(i, j) = ZI(i, j) * weight + Zenhanced(i, j) * (1 - weight);
            }
        }
    }
    ZI = Zenhanced;

    // Original variance-based filtering
    if (f_pc) {
        for (unsigned int i = 0; i < ((ZI.n_rows - 1) / interpol_value); i += 1) {
            for (unsigned int j = 0; j < ZI.n_cols - 5; j += 1) {
                double promedio = 0;
                double varianza = 0;
                for (unsigned int k = 0; k < interpol_value; k += 1) {
                    promedio = promedio + ZI((i * interpol_value) + k, j);
                }
                promedio = promedio / interpol_value;

                for (unsigned int l = 0; l < interpol_value; l++) {
                    varianza = varianza + pow((ZI((i * interpol_value) + l, j) - promedio), 2.0);
                }

                if (varianza > max_var) {
                    for (unsigned int m = 0; m < interpol_value; m++) {
                        Zout((i * interpol_value) + m, j) = 0;
                    }
                }
            }
        }
        ZI = Zout;
    }

    // Debug visualization for far-range points with fixed bounds
    if (ZI.n_rows > 0 && ZI.n_cols > 0) {
        ROS_INFO("Creating cv::Mat with dimensions: %d x %d", ZI.n_rows, ZI.n_cols);
        cv::Mat range_img = cv::Mat(ZI.n_rows, ZI.n_cols, CV_32F);
        for (unsigned int i = 0; i < ZI.n_rows && i < (unsigned int)range_img.rows; ++i) {
            for (unsigned int j = 0; j < ZI.n_cols && j < (unsigned int)range_img.cols; ++j) {
                range_img.at<float>(i, j) = ZI(i, j);
            }
        }
        cv::normalize(range_img, range_img, 0, 255, cv::NORM_MINMAX, CV_8U);

        cv::Mat far_mask = cv::Mat(ZI.n_rows, ZI.n_cols, CV_8U, cv::Scalar(0));
        for (unsigned int i = 0; i < ZI.n_rows && i < (unsigned int)far_mask.rows; ++i) {
            for (unsigned int j = 0; j < ZI.n_cols && j < (unsigned int)far_mask.cols; ++j) {
                if (ZI(i, j) > far_depth_threshold) {
                    far_mask.at<uint8_t>(i, j) = 255;
                }
            }
        }

        sensor_msgs::ImagePtr range_msg = cv_bridge::CvImage(std_msgs::Header(), "mono8", range_img).toImageMsg();
        sensor_msgs::ImagePtr far_msg = cv_bridge::CvImage(std_msgs::Header(), "mono8", far_mask).toImageMsg();
